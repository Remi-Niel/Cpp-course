%class-name Parser

%filenames parser
%parsefun-source parse.cc

%baseclass-preinclude rulevalue.h
%stype RuleValue

%scanner ../scanner/scanner.h

%token  NUMBER
        IDENT
        END

%right  '=' MULa DIVa MODa ADDa SUBa LSHIFTa RSHIFTa ANDa ORa XORa
%right  '~'
%left   '|'
%left   '^'
%left   '&'
%left   LSHIFT RSHIFT
%left   '+' '-'
%left   '*' '/' '%'
%right  uMinus

// %debug

%%

lines:
    lines line
|
    line
;


line:
    expr '\n'
    {
        display($1);
    }
|
    error '\n'    
    {
        prompt();
    }
|
    '\n'
    {
        prompt();
    }
|
    END '\n'
    {
        done();
    }
;

expr:
    NUMBER
    {
        $$ = value();
    }
|
    IDENT
    {
        $$ = variable();
    }
|
    '-' expr            %prec uMinus
    {
        $$ = negate($2);
    }
|
    '~' expr
    {
        $$ = bNOT($2);
    }
|
    expr '*' expr
    {
        $$ = mul($1, $3);
    }    
|
    expr '/' expr
    {
        $$ = div($1, $3);
    }    
|
    expr '%' expr
    {
        $$ = mod($1, $3);
    }    
|
    expr '+' expr
    {
        $$ = add($1, $3);
    }    
|
    expr '-' expr
    {
        $$ = sub($1, $3);

    }   
|
    expr LSHIFT expr
    {
        $$ = lshift($1, $3);

    }   
|
    expr RSHIFT expr
    {
        $$ = rshift($1, $3);

    } 
|
    expr '&' expr
    {
        $$ = bAND($1, $3);

    } 
|
    expr '^' expr
    {
        $$ = bXOR($1, $3);

    } 
|
    expr '|' expr
    {
        $$ = bOR($1, $3);

    }    
|
    '(' expr ')'
    {
        $$ = $2;
    }
|
    expr '=' expr
    {
        $$ = assign($1, $3);
    }
|   //All compound assignments work as follows
    //$1 is copied, then oper(copy, $3) is used
    // as rvalue in the assignment. The copy is
    // needed because oper() changes lhs, such
    // that it is not an lvalue anymore hence assign
    // can't be done to it afterwards.
    expr MULa expr
    {
        RuleValue tmp{$1};
        $$ = assign($1, mul(tmp, $3));
    }
|
    expr DIVa expr
    {
        RuleValue tmp{$1};
        $$ = assign($1, div(tmp, $3));
    }
|
    expr MODa expr
    {
        RuleValue tmp{$1};
        $$ = assign($1, mod(tmp, $3));
    }
|
    expr ADDa expr
    {
        RuleValue tmp{$1};
        $$ = assign($1, add(tmp, $3));
    }
|
    expr SUBa expr
    {
        RuleValue tmp{$1};
        $$ = assign($1, sub(tmp, $3));
    }
|
    expr LSHIFTa expr
    {
        RuleValue tmp{$1};
        $$ = assign($1, lshift(tmp, $3));
    }
|
    expr RSHIFTa expr
    {
        RuleValue tmp{$1};
        $$ = assign($1, rshift(tmp, $3));
    }
|
    expr ANDa expr
    {
        RuleValue tmp{$1};
        $$ = assign($1, bAND(tmp, $3));
    }
|
    expr ORa expr
    {
        RuleValue tmp{$1};
        $$ = assign($1, bOR(tmp, $3));
    }
|
    expr XORa expr
    {
        RuleValue tmp{$1};
        $$ = assign($1, bXOR(tmp, $3));
    }
;